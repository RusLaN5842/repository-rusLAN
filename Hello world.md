  # Работа с Git

## 1. Проверка установленного Git
 В терминале выполнить команду  `git version`
Если git установлен, появиться сообщение с информацией о версии программы. Если нет то выдаст ошибку,

## 2. Установка git.
Загрузить последнюю версию git с сайта

https://git-scm.com/downloads

Устанавливаем с настройками по умолчанию.


## 3. Настройка Git
При первом использовании необходимо представиться. Для этого необходимо ввести в терминале команды:
```
git config --global user.name "Ваше имя"
git config --global user.mail "Ваша почта"
```
## 4. Создание репозитория.
Получить репозиторий можно двумя способами.
1. В терминале пререходим, к папке в которой хотим создать репозиторий. Вводим команду:
```
git init
```  
или, если хотите скопировать существующий:
```  
git clone <адрес репозитория>
```
## 5. Удалённые репозитории

Пока что мы обсуждали использование Git только на локальной машине. Однако мы можем хранить историю коммитов удалённых репозиториев, которую можно отслеживать и обновлять. git remote -v выводит список удалённых репозиториев, которые мы отслеживаем, и имена, которые мы им присвоили.

При использовании команды git clone <url репозитория> мы не только загружаем себе копию репозитория, но и неявно отслеживаем удалённый сервер, который находится по указанному адресу и которому присваивается имя origin.

**Наиболее употребляемые команды**:
* git remote add <имя> <url> — добавляет удалённый репозиторий с заданным именем;
* git remote remove <имя> — удаляет удалённый репозиторий с заданным именем;
* git remote rename <старое имя> <новое имя> — переименовывает удалённый репозиторий;
* git remote set-url <имя> <url> — присваивает репозиторию с именем новый адрес;
* git remote show <имя> — показывает информацию о репозитории.

## 6. Добавление Коммитов
Команда `git commit `

Откроет текстовый редактор для ввода сообщения коммита. Также эта команда принимает несколько аргументов:
```
*-m позволяет написать сообщение вместе с командой, не открывая редактор. Например git commit -m "Пофиксил баг"

* -a переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом);

* --amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.
```
## Советы для эффективного введения в Git:

1. Коммитьте как можно чаще.

2. Одно изменение — один коммит: не помещайте все не связанные между собой изменения в один коммит, разделите их, чтобы было проще откатиться.

3. Формат сообщений: заголовок должен быть в повелительном наклонении, меньше 50 символов в длину и должен логически дополнять фразу this commit will ___(this commit will fix bugs — этот коммит исправит баги). Сообщение должно пояснять, почему был сделан коммит, а сам коммит показывает, что изменилось.

4. Если у вас много незначительных изменений, хорошим тоном считается делать небольшие коммиты при разработке, а при добавлении в большой репозиторий объединять их в один коммит.

## Просмотр изменений в файловых системах
Команда git status отображает все файлы, которые различаются между тремя разделами. У файлов есть 4 состояния:

1. Неотслеживаемый (untracked) — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).

2. Изменён (modified) — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).

3. Подготовлен (staged) — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).

4. Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.

## Примечания
*Файл может быть одновременно в состоянии «изменён» и «подготовлен», если версия в рабочей директории новее, чем в области подготовленных файлов, которая в свою очередь новее версии в HEAD.*

Мы можем использовать опцию -s для команды git status, чтобы получить более компактный вывод (по строке на файл). Если файл не отслеживается, то будет выведено ??; если он был изменён, то его имя будет красным, а если подготовлен — зелёным.

## Чтобы посмотреть сами изменения, а не изменённые файлы, можно использовать следующие команды:

* git diff — сравнение рабочей директории с областью подготовленных файлов;

* git diff --staged — сравнение области подготовленных файлов с HEAD.
Если использовать аргумент <файл/папка>, то diff покажет изменения только для указанных файлов/папок, например git diff src/.

## Обновление файловых систем

Команда git add <файл/папка> обновляет область подготовленных файлов версиями файлов/папок из рабочей директории.

Команда git commit обновляет HEAD новым коммитом, который делает снимки файлов в области подготовленных файлов.

**Действие команды git reset <коммит> состоит из трёх потенциальных шагов**

* Переместить указатель HEAD на <коммит> (например, при откате коммита в рабочей директории и области подготовленных файлов будут более новые версии файлов, чем в HEAD). Также указатель HEAD ветки будет перемещён на этот коммит.

* Обновить область подготовленных файлов содержимым коммита. В таком случае только в рабочей директории будут новейшие версии файлов.

* Обновить рабочую директорию содержимым области подготовленных файлов. С этим нужно быть осторожнее, поскольку в итоге будут уничтожены изменения файлов.

* По умолчанию команда git reset выполняет только шаги 1 и 2, однако её поведение можно изменить с помощью опций --soft (только 1 шаг) и --hard (все шаги).

    Если передать путь к файлу/папке, то команда будет выполнена только для них, например git reset --soft HEAD~1 src/.

    Команда git checkout HEAD <файл> приводит к тому же результату, что и git reset --hard HEAD <файл> — перезаписывает версию файла в области подготовленных файлов и в рабочей директорией версией из HEAD, то есть отменяет изменения после последнего коммита.

    С другой стороны, git checkout <файл> (уже без HEAD) перезаписывает версию файла в рабочей директории версией в области подготовленных файлов, то есть отменяет изменения с момента последней подготовленной версии.

    Наконец, git rm <файл> отменяет отслеживание файла и удаляет его из рабочей директории, опция --cached позволит сохранить файл.